# 서로소 집합 (Disjoint-sets) (p302~)

- 교집합이 없는 집합

<br>

<br>

## 상호배타 집합 연산

### make-set(x)

- 모든 원소를 다 쪼갠다음에 원소가 하나인 집합을 만들기
- make-set에서는 자기가 대표자
- 대표자(자기자신)를 모두 -1로 초기화

### Find-set(x)

- 집합을 알아오는 것(대표자를 알아오는 것)

### Union(x,y)

- 집합을 합치는 것(x집합의 대표자와 y집합의 대표자가 서로 다를 때 합치는 것) => 대표자를 합치는 것
- x와 y가 서로 다른 집합에 있을때(이미 상호배타 집합인 상태를 만족할 때) 합치는 것
  - 이를 알아내기 위해 내부적으로 Find-Set이 동반됨

<br>

<br>

## 상호 배타 집합 표현

집합을 트리로 만들기 때문에 나중에 트리의 depth(깊이)가 깊어지면 대표자를 찾아가는데 오래걸리기 떄문에 이를 해결하는 방법이 두가지가 있음(=depth를 따지지 않는방법)

- 랭크 관리
  - 두 집합을 합칠 때 rank가 낮은 집합을 rank가 높은 집합에 붙인다
  - rank는 자신을 루트노드로 하는 서브트리의 높이를 의미

<br>

- **패스 압축(Path Compression)** 
  - 자신의 대표자를 찾으면 자신의 부모로 모두 바꿈
  - Find-Set을 행하는 과정에서 만나는 모든 노드들이 직접 root를 가리키도록 포인터를 바꾸어 준다
  - 문제점 : 내 위쪽만 path compression하게 됨 => 기존의 내 자식노드들은 적용되지 않음

<br>

### 랭크  관리

- 같은 집합의 원소들을 하나의 연결리스트로 관리
- 연결리스트의 맨 앞의 원소를 집합의 대표 원소로 정한다
  - 트리의 경우 자식 노드가 부모 노드를 가리키며 루트 노드가 대표자가 된다
  - 부모는 하나, 자식은 여러개
  - 자식관점에서 부모따라가기
- 각 원소는 집합의 대표원소를 가리키는 링크를 갖는다